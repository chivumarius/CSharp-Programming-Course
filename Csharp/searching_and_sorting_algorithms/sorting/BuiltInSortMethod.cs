/*▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀
                    • "SEARCHING" & "SORTING" •
                            • "SORTING" •
                    ───────────────────────────
                  
                  
                  
    ▬ "Sorting"
        → is a "Process" 
        → of "Arranging" the "Elements" 
        → of a "Collection" 
        → in a "Specific Order", 
        → such as: 
            •► "Ascending" Order or 
            •► "Descending" Order, 
        → "Based" on "Certain Criteria". 
        
        
        ♦ The "Main Purpose" of "Sorting" 
            → is to "Facilitate Search" 
            → and "Access" to "Stored Data" 
            → by "Organizing It" 
            → in an "Orderly Form".

    
    
    
    ▬ Some of the Main "Sorting Algorithms" include:

        1. "Selection Sort": 
            ♦ The "Algorithm" 
                → "Repeatedly Picks" 
                → the "Smallest Element" 
                → from the "Unordered List" 
                → and "Places It" 
                → at the "Beginning" 
                → of the "Ordered List". 


            ♦ "It" 
                → has the "Same Time Complexity" as
                → "Bubble Sort" and
                → "Insertion Sort", 
                → it is "More Efficient" 
                → in "Practice".
                
                

        2. "Bubble Sort": 
            ♦ "It" 
                → is a Simple "Sorting Algorithm" 
                → that "Iterates" 
                → through the "List" 
                → and "Swaps Neighboring Elements" 
                → if "They" are in the "Wrong Order". 
            
            
            ♦ It is "Efficient" 
                → for small "Lists", 
                → but has "High Time Complexity" 
                → for "Large Lists".



        3. "Quick Sort": 
            ♦ "It" is an "Efficient Sorting Algorithm" 
                → that "Uses" 
                → the "Divide" and "Conquer" Method 
                → to "Sort" the "List". 
            
            
            ♦ "Picks" 
                → a "Pivot Element", 
                → Places "Smaller Elements" "Before"
                → the "Pivot"  
                → and "Larger" Ones "After" 
                → the "Pivot", 
                → then "Recursively Sorts" 
                → the "Two Sub-Lists". 
            
            
            ♦ It has an Average "Runtime Complexity" of 
                    •►"O(n log n)", 
                → but may have "Bad Cases" with 
                    •► "O(n^2)" 
                → "Time Complexity".

        
        
        
         4. "Merge Sort": 
            ♦ "It" 
                → is an "Efficient" and "Stable Sorting Algorithm" 
                → that "Splits" the "List" 
                → in "Half", 
                → "Sorts" Each "Half" Separately, 
                → then "Combines" the "Sorted Halves" 
                → into a "Single Sorted List". 
            
            
            ♦ "It" 
                → has an "Execution Time Complexity" of 
                    •► "O(n log n)".



        5. "Insertion Sort": 
            ♦ This "Algorithm" 
                → "Sorts" the "List" 
                → by "Building" a "Sorted Part" 
                → on the "Left Side" 
                → and "Inserting" 
                → the U"nordered Elements" 
                → "One" by "One" 
                → into the "Sorted Part". 
            
            
            ♦ It is "Efficient" 
                → for "Small Lists", 
                → but has "High Time Complexity" 
                → for "Large Lists".
        
       
    
        6. "Radix Sort":
            → is a "Non-Comparative Sorting Algorithm" 
            → that "Works" 
            → on the "Principle" 
            → of "Dividing Numbers" 
            → into "Groups" 
            → "Based" on their "Digits", 
            → "Starting" with the "Least Significant" and
            → "Continuing" with the "Most Significant".
            
            
            ♦ "It" is "Efficient" 
                → for S"orting Integers" 
                → and "Other Types" of "Keys", 
                → and Its "Execution Time" 
                → is "Influenced" 
                → by the "Number" of "Digits" 
                → and the "Number" of "Distinct Values" 
                → a "Digit" can "Have".
            
            
            ♦ There are "Two Main Variants": 
                    1- "Radix Sort LSD" ("Least Significant Digit") and 
                    2- "Radix Sort MSD ("Most Significant Digit"), 
                → each with "Specific Uses" 
                → and "Advantages".


         7. "Heap Sort": 
            ♦ It is an "Efficient Sorting Algorithm "
                → that "Uses" a "Heap" Data Structure 
                → to "Sort" the "List". 
            
            
            ♦ It "Relies" on "Picking" 
                → the "Largest/ Smallest Element" 
                → from the "Heap" 
                → and "Removing It" 
                → to "Build" the "Sorted List". 
            
            
            ♦ "It" 
                → has an "Execution Time Complexity" of 
                    •► "O(n log n)".


         8. "Shell Sort" (Sort by fragmentation):
            → is a "Comparison-Based Sorting Algorithm" 
            → that "Improves" 
            → the "Performance" of "Insertion Sort" 
            → by "Breaking" the "List" 
            → into "Smaller Sub-Lists" 
            → and Applying "Insertion Sort" 
            → to "Each Sub-List".
            
            
            
            ♦ It "Uses" 
                → a "Sequence" of "Intervals" (also Called "Gaps") 
                → to "Determine" "Sub-Lists" 
                → of "Different Sizes".
            
            
            
            ♦ "It" has a "Time Complexity Intermediate" 
                → between 
                    •► "O(n) 
                → and 
                    •► "O(n^2), 
                → being "More Efficient" 
                → than the "Insertion Sort Algorithm" 
                → on "Large Lists", 
                → but can be "Slower" 
                → than "Other More Efficient Algorithms" such as 
                → "Quick Sort" or 
                → "Merge Sort".
               
▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀*/
namespace CSharp.searching_and_sorting_algorithms.sorting;




public class BuiltInSortMethod
{
    
    // ▬ "RunBuiltInSortMethod()" Method ▬
    public static void RunBuiltInSortMethod()
    {
        // ▼ "Array" ▼
        int[] array1 = new int[6] { 3, 1, 6, 2, 8, 0 };
        
        

        // ▼ Call ".Sort()" Method of "Array" ▼
        Array.Sort(array1);
        
        // ▼ Print "Sorted Array" ▼
        Console.WriteLine("Built-In Sort() Method of the Array: " + string.Join(", ", array1));
    }
} 